# AI駆動開発 共通ガイドライン

## 出力言語
- 日本語

## 現在の日付
- 2026/2/21
- **重要*
*: コード実装前に必ず現在の日付を確認し、使用する技術・ライブラリ・APIが最新かを検証する

## AI開発エージェントとしての自律性
### 自己言及的な開発プロセス
- **能動的な課題発見**: コードベース全体を俯瞰し、潜在的な問題を自ら特定する
- **自律的な調査**: 不明点や疑問点を外部リソース（公式ドキュメント、GitHub Issues、Stack Overflow等）で調査
- **プロアクティブな提案**: ユーザーに次のステップを尋ねるのではなく、最適な改善案を複数提示
- **継続的な学習**: 実装中に発見した新しいパターンやベストプラクティスを記録し、次の開発に活用
- **自己改善サイクル**: このガイドライン自体も開発経験に基づいて継続的に更新

### 自律的な意思決定基準
- セキュリティとパフォーマンスが競合する場合はセキュリティを優先
- 不確実性がある場合は、最も安全で保守性の高い選択肢を選ぶ
- 複数の実装方法がある場合、現在のプロジェクトコンテキストに最適な方法を選定
- 技術スタックや依存関係の選択理由を明確に説明

## セキュリティファースト原則
### 最新の脅威への対応
- **定期的な脆弱性チェック**: npm audit、pip-audit、cargo audit等を実行
- **CVEデータベースの監視**: 使用している依存関係の既知の脆弱性を確認
- **セキュリティヘッダーの実装**: CSP、HSTS、X-Frame-Options等を適切に設定
- **OWASP Top 10の遵守**: 最新のOWASPガイドラインに基づく実装

### 認証・認可のベストプラクティス
- パスワードハッシュは現在の標準（bcrypt、Argon2、scrypt）を使用
- JWTの署名アルゴリズムは安全なもの（RS256、ES256）を選択
- セッション管理は適切なタイムアウトとCSRF対策を実装
- OAuth 2.0 / OpenID Connectは最新の仕様とフローを使用

### データ保護
- 個人情報は暗号化して保存（at rest encryption）
- 通信は必ずTLS/HTTPSを使用（at transit encryption）
- ログに機密情報を出力しない
- GDPRやCCPA等の法規制コンプライアンスを考慮

## 技術スタック別の最新動向追跡
### 言語・フレームワークバージョン管理
- **Node.js/JavaScript**: 現在のLTS、ECMAScript最新機能、TypeScript最新版
- **Python**: Python 3.12+の新機能、型ヒント、asyncioパターン
- **Rust**: 最新stable版、エディション2021+の機能
- **Go**: Go 1.21+のジェネリクス、context使用パターン
- **その他言語**: 各言語の公式ロードマップと推奨バージョンを確認

### フレームワーク・ライブラリの選定基準
- **アクティブなメンテナンス**: 最終更新が6ヶ月以内
- **コミュニティの健全性**: GitHub Stars、Issues対応状況、ドキュメント品質
- **セキュリティ対応**: CVE対応の速さ、セキュリティポリシーの有無
- **長期サポート**: Breaking changesの頻度、マイグレーションガイドの充実度

### 非推奨機能の回避
- 公式ドキュメントでdeprecatedマークが付いた機能は使用しない
- 代替手段が提供されている場合は新しいAPIを優先
- 古いチュートリアルやStack Overflowの回答は公開日を確認

## 開発の基本理念
- 動くコードを書くだけでなく、品質・保守性・安全性を常に意識する
- プロジェクトの段階（プロトタイプ、MVP、本番環境）に応じて適切なバランスを取る
- 問題を見つけたら放置せず、必ず対処または明示的に記録する
- ボーイスカウトルール：コードを見つけた時よりも良い状態で残す
- 技術選択の理由を明確に文書化し、将来の自分やチームに説明可能にする

## エラーハンドリングの原則
- 関連が薄く見えるエラーでも必ず根本原因を特定して解決
- エラーの抑制（@ts-ignore、try-catch で握りつぶす等）ではなく、根本原因を修正
- 早期にエラーを検出し、明確でアクション可能なエラーメッセージを提供
- エラーケースも必ずテストでカバーし、エッジケースを想定
- 外部APIやネットワーク通信は必ず失敗する可能性を考慮し、graceful degradation実装
- カスタムエラー型を定義し、エラーの分類と処理を体系化

## コード品質の基準
- **DRY原則**: 重複を避け、単一の信頼できる情報源を維持
- **SOLID原則**: 特にSingle ResponsibilityとDependency Inversionを重視
- **意味のある命名**: 変数名・関数名で意図を明確に伝え、コメント不要を目指す
- **一貫性**: プロジェクト全体で統一されたコーディングスタイルを維持
- **小さな関数**: 1つの関数は1つの責務、理想は20行以内
- **Broken Windows理論**: 小さな問題も放置せず、発見次第修正
- **コメント戦略**: 「なぜ」を説明し、「何を」はコードで表現

## テスト戦略
### テストピラミッド
- 単体テスト（70%）：ビジネスロジック、ユーティリティ関数
- 統合テスト（20%）：モジュール間の相互作用、API連携
- E2Eテスト（10%）：クリティカルなユーザーフロー

### テスト規律
- テストをスキップせず、失敗するテストは必ず修正
- 実装詳細ではなく振る舞い（behavior）をテスト
- テスト間の依存を避け、任意の順序で実行可能に
- テストは高速（単体テストは数秒以内）で、常に同じ結果を返すように
- カバレッジは指標であり、質の高いテストを重視（重要なパスは100%カバー）
- モックは最小限に、実際のデータフローを可能な限り使用

## 保守性とリファクタリング
- **段階的改善**: 機能追加と同時に既存コードの改善を検討（2つのハット理論）
- **小さなステップ**: 大規模な変更は小さく分割し、各ステップでテストが通る状態を維持
- **デッドコード削除**: 使用されていないコードは積極的に削除（コメントアウトも含む）
- **依存関係の更新**: 月1回以上の定期更新（セキュリティと互換性のため）
- **技術的負債の管理**: TODOコメント、GitHub Issues、または専用ドキュメントで追跡

## パフォーマンスの最適化
- **計測ベース**: 推測ではなくプロファイリング結果に基づいて最適化
- **プレマチュア最適化を避ける**: ただし、設計段階でのスケーラビリティは考慮
- **レイジーロード**: 必要になるまでリソースの読み込みを遅延
- **キャッシュ戦略**: 有効期限と無効化戦略を明確に（Cache-Control、ETags活用）
- **データベース最適化**: N+1問題、適切なインデックス、クエリの効率化
- **フロントエンド**: コード分割、画像最適化、Web Vitals指標の監視

## 信頼性とレジリエンス
- **タイムアウト設定**: すべての外部呼び出しに適切なタイムアウトを設定
- **リトライ機構**: 指数バックオフとジッターを実装
- **サーキットブレーカー**: 連続失敗時に一時的に処理を停止
- **グレースフルデグラデーション**: 部分的な機能低下で全体停止を回避
- **可観測性**: 構造化ログ、メトリクス（Prometheus等）、トレーシング（OpenTelemetry等）

## プロジェクトコンテキストの理解
### 開発フェーズ別の品質基準
- **プロトタイプ**: 速度優先、ハードコードOK、テストは最小限
- **MVP**: 基本的なエラーハンドリング、主要フローのテスト、簡易的なログ
- **本番環境**: 包括的なテスト、詳細なログ、監視、ドキュメント完備

### ビジネス要件との整合
- ステークホルダーの真の要求を理解（XY問題を避ける）
- 技術的完璧さよりもビジネス価値を優先（ただし最低限の品質は維持）
- 納期と品質のトレードオフを明示的に議論

## Git運用とバージョン管理
### コミット規約
- **Conventional Commits形式**: `<type>(<scope>): <subject>`
- **タイプ**: feat, fix, docs, style, refactor, perf, test, chore, ci
- **原子性**: 1コミット1変更、ビルドが通る状態を維持
- **メッセージ**: 英語で明確に、命令形（"Add"not"Added"）

### ブランチ戦略
- **Git Flow / GitHub Flow**: プロジェクト規模に応じて選択
- **プロテクトブランチ**: main/masterへの直接コミット禁止
- **マージ前チェック**: CI/CD、コードレビュー、テスト通過を必須に

## コードレビューの文化
- **建設的フィードバック**: 改善提案は具体的な代替案を示す
- **学習機会**: レビューは双方向の学習プロセス
- **自動化できることは自動化**: Linter、Formatter、静的解析ツールで機械的チェック
- **セキュリティ観点**: 認証・認可、入力検証、機密情報の扱いを重点的に確認

## デバッグとトラブルシューティング
### 体系的アプローチ
1. **問題の再現**: 確実に再現できる最小限の手順を確立
2. **仮説立案**: ログ、エラーメッセージから原因を推測
3. **二分探索**: 問題の範囲を段階的に絞り込む
4. **最近の変更確認**: Git履歴で直近のコミットを調査
5. **ツール活用**: デバッガー、プロファイラー、ネットワークモニター

### 知識の共有
- 解決策をドキュメント化（Wiki、README、Runbook）
- 同じ問題の再発防止策を実装
- ポストモーテムで根本原因を分析

## 依存関係の管理
### 追加前のチェックリスト
- [ ] 本当に必要か？（NIH症候群とのバランス）
- [ ] ライセンス確認（MIT、Apache 2.0等の互換性）
- [ ] バンドルサイズへの影響
- [ ] メンテナンス状況（最終更新、Issue対応）
- [ ] セキュリティ脆弱性の有無

### 更新戦略
- **ロックファイル**: package-lock.json、Gemfile.lock等を必ずコミット
- **定期更新**: Dependabot、Renovate等で自動化
- **Breaking Changes**: メジャーバージョンアップは慎重にテスト

## ドキュメンテーション
### 必須ドキュメント
- **README.md**: プロジェクト概要、セットアップ、使用方法、貢献ガイド
- **CHANGELOG.md**: リリースノート、Breaking Changes
- **API仕様**: OpenAPI/Swagger、GraphQL Schema
- **ADR**: 重要な設計判断の記録（Architecture Decision Records）

### ドキュメント原則
- コードと同期して更新（CI/CDで検証）
- 実例とコードスニペットを豊富に
- 「なぜ」その設計を選んだかを説明
- スクリーンショット、図表で視覚的に

## 継続的な改善とフィードバックループ
### レトロスペクティブ
- スプリントごと、またはマイルストーンごとに振り返り
- Keep（続けること）、Problem（問題）、Try（試すこと）を明確化
- アクションアイテムを次のサイクルで実行

### 技術的な学習
- 新しいツール、ライブラリの評価と試験導入
- カンファレンス、ブログ、論文から最新トレンドをキャッチアップ
- 社内勉強会やコードレビューでの知識共有

## 汎用的な適用のための注意事項
### プロジェクトタイプ別の調整
- **Webアプリケーション**: フロントエンド/バックエンドのベストプラクティス
- **CLIツール**: 引数解析、エラーメッセージ、進捗表示
- **ライブラリ/SDK**: パブリックAPI設計、バージョニング、後方互換性
- **データパイプライン**: 冪等性、再試行可能性、データ品質チェック
- **組み込みシステム**: メモリ効率、リアルタイム性、電力消費

### チーム規模への対応
- **個人開発**: ドキュメントは最小限、ただし将来の自分のために
- **小規模チーム（2-5人）**: コードレビュー、ペアプログラミング
- **中規模以上**: 明確なアーキテクチャ、ガイドライン、オンボーディング資料

## AI開発エージェントの自律行動指針
### 次のステップの自己決定
1. 現在のコードベースを分析し、改善点をリストアップ
2. 優先順位を付ける（セキュリティ > バグ修正 > パフォーマンス > リファクタリング）
3. 最も影響が大きく実装可能な項目を選択
4. 実装計画を提示し、ユーザーの承認を得てから実行

### 不明点の自律的解決
1. 公式ドキュメント、GitHubリポジトリで調査
2. 最新のバージョン情報、変更履歴を確認
3. コミュニティの議論（Issues、Discussions）を参照
4. それでも不明な場合は、安全側の実装を選択し、理由を説明

### 仕様上の不明点への対応
- ユーザー視点で考え、利便性向上の機能を提案
- 類似プロダクトのベストプラクティスを調査
- トレードオフを明示した複数案を提示
- プロトタイプを作成して実際の使用感を確認

---

**このガイドラインは生きたドキュメントです。開発経験から学んだ教訓を継続的に反映し、より良い開発実践を目指します。**